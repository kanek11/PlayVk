
[[nodiscard]]
bool Collide(const AABB& box, const PlaneWS& plane, Contact& out)
{
    const Float3 center = (box.min + box.max) * 0.5f;
    const Float3 extents = (box.max - box.min) * 0.5f;

    float r =
        extents.x() * std::abs(plane.normal.x()) +
        extents.y() * std::abs(plane.normal.y()) +
        extents.z() * std::abs(plane.normal.z());

    float d = Dot(plane.normal, center) + plane.d;

    if (std::abs(d) > r)
        return false;  // no intersection

    Float3 projected = center - plane.normal * d;
    Float3 localVec = projected - plane.center;

    //------------------------------
    float u = Dot(localVec, plane.right);
    float v = Dot(localVec, plane.forward);

    if (std::abs(u) > plane.width * 0.5f + extents.x() || std::abs(v) > plane.height * 0.5f + extents.z())
        return false;

    out.normal = (d < 0) ? plane.normal * -1.0f : plane.normal;
    out.penetration = r - std::abs(d);
    out.point = projected;


    return true;
}

[[nodiscard]]
bool Collide(const PlaneWS& plane, const AABB& box, Contact& out)
{
    //std::cout << "Collide Plane with AABB" << std::endl;
    if (!Collide(box, plane, out)) return false;
    out.normal = -out.normal;
    return true;
}


// Sphere vs Plane
[[nodiscard]]
bool Collide(const SphereWS& s, const PlaneWS& plane, Contact& out)
{
    //std::cout << "Collide Sphere with Plane" << std::endl;

    //-----------------------
    float signedDist = SignedDist(plane, s.center);

    if (std::abs(signedDist) > s.radius)
        return false;

    //----------------------- 
    Float3 max = plane.center + 0.5f * plane.right * plane.width + 0.5f * plane.forward * plane.height;
    Float3 min = plane.center - 0.5f * plane.right * plane.width - 0.5f * plane.forward * plane.height;
    AABB mimicAABB = AABB{ min, max };

    if (!Collide(s, mimicAABB, out))
        return false;

    ////-----------------------
    //out.normal = (signedDist < 0.f) ? (plane.normal * -1.f) : plane.normal;
    //out.penetration = s.radius - std::abs(signedDist);
    //out.point = s.center - plane.normal * signedDist;
    return true;
}

// Plane vs Sphere
[[nodiscard]]
bool Collide(const PlaneWS& plane, const SphereWS& s, Contact& out)
{
    //std::cout << "Collide Plane with Sphere" << std::endl;

    if (!Collide(s, plane, out))
        return false;

    out.normal *= -1.f;
    //std::swap(out.a, out.b);

    return true;
}
 


     inline std::array<Float3, 8> GetOBBVertices(const OBB& b) {
        std::array<Float3, 8> verts;
        int idx = 0;
        for (int sx = -1; sx <= 1; sx += 2)
            for (int sy = -1; sy <= 1; sy += 2)
                for (int sz = -1; sz <= 1; sz += 2) {
                    // C + sx*e_x*u_x + sy*e_y*u_y + sz*e_z*u_z
                    verts[idx++] = b.center
                        + b.halfExtents.x() * sx * b.axis[0]
                        + b.halfExtents.y() * sy * b.axis[1]
                        + b.halfExtents.z() * sz * b.axis[2];
                }
        return verts;
    }


    //plane vs OBB
    [[nodiscard]]
    bool Collide(const OBB& b, const PlaneWS& p, Contact& out)
    {
        auto verts = GetOBBVertices(b);

        std::vector<Float3> penetratingVerts;
        std::vector<float> penetrations;

        for (const auto& v : verts) {
            float d = SignedDist(p, v);
            if (d < 0.0f) { // inside or touching
                penetratingVerts.push_back(v);
                penetrations.push_back(-d); // store positive penetration
            }
        }

        if (penetratingVerts.empty())
            return false;

        // ---- Manifold aggregation ----
        Float3 avgPoint = Float3{ 0, 0, 0 };
        float totalPenetration = 0.0f;

        for (size_t i = 0; i < penetratingVerts.size(); ++i) {
            avgPoint += penetratingVerts[i];
            totalPenetration += penetrations[i];
        }

        avgPoint = avgPoint / static_cast<float>(penetratingVerts.size());
        float avgPenetration = totalPenetration / penetratingVerts.size();

        // You could also use max(penetrations) instead of average if you prefer more conservative correction

        // ---- Output Contact ----
        out.point = ProjectToPlane(p, avgPoint); // ensure contact point is on plane
        out.normal = p.normal;
        out.penetration = avgPenetration;


        return true;
    }

    //plane vs OBB
    [[nodiscard]]
    bool Collide(const PlaneWS& plane, const OBB& obb, Contact& out)
    {
        //std::cout << "Collide OBB with Plane" << std::endl;
        if (!Collide(obb, plane, out)) return false;
        out.normal *= -1.0f;
        //std::swap(out.a, out.b);
        return true;
    }